<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grand Luxury Tree - Local Images</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Times New Roman', serif; touch-action: none; }
        
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }
        
        /* UI Overlay - Responsive Layout */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; 
            align-items: center;
            padding-top: 15vh; 
            box-sizing: border-box;
            transition: opacity 0.5s ease;
        }

        @media (min-width: 768px) {
            #ui-layer { padding-top: 8vh; }
        }
        
        .ui-hidden { opacity: 0 !important; pointer-events: none !important; }

        /* Loading */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .spinner {
            width: 40px; height: 40px; border: 1px solid rgba(212, 175, 55, 0.2); 
            border-top: 1px solid #d4af37; border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loader-text {
            color: #d4af37; font-size: 14px; letter-spacing: 4px; margin-top: 20px;
            text-transform: uppercase; font-weight: 100;
        }

        /* Typography - Smart Scaling */
        h1 { 
            color: #fceea7; 
            font-size: clamp(40px, 10vw, 90px); 
            margin: 0; font-weight: 400; 
            letter-spacing: 0.1em; 
            text-shadow: 0 0 30px rgba(252, 238, 167, 0.6); 
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', 'Times New Roman', serif;
            opacity: 0.9;
            text-align: center;
            line-height: 1.2;
            pointer-events: auto; 
        }

        /* HIDDEN WEBCAM */
        #webcam-wrapper { position: fixed; bottom: 0; left: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none; z-index: -100; overflow: hidden; }
        #webcam { width: 100%; height: 100%; object-fit: cover; }

        /* Info & Guide */
        #debug-info { position: absolute; bottom: 10px; left: 10px; color: rgba(212, 175, 55, 0.4); font-size: 10px; font-family: monospace; z-index: 50; pointer-events: none; }
        
        #guide-text { 
            position: absolute; bottom: 40px; width: 100%; text-align: center; 
            color: #d4af37; font-size: 12px; letter-spacing: 2px; 
            text-transform: uppercase; z-index: 5; pointer-events: none;
            text-shadow: 0 2px 10px #000;
            font-family: 'Cinzel', serif;
        }
    </style>
    
    <style> @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap'); </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">Loading Memories...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>BIN NA<br>RECAP 2025</h1>
    </div>

    <div id="webcam-wrapper"><video id="webcam" autoplay playsinline></video></div>
    <div id="debug-info">Initializing AI...</div>
    <div id="guide-text">CAO VĂN NAM ❤️ NGUYỄN THỊ THỦY</div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        const isMobile = window.innerWidth < 768;

        const CONFIG = {
            colors: { bg: 0x000000, champagneGold: 0xffd966, deepGreen: 0x03180a, accentRed: 0x990000 },
            particles: { 
                count: isMobile ? 1000 : 2000, 
                dustCount: isMobile ? 1200 : 2500, 
                treeHeight: 24, 
                treeRadius: 8 
            },
            camera: { z: 50 },
            preload: {
                // ĐÃ CẬP NHẬT ĐƯỜNG DẪN ẢNH CỤC BỘ
                images: [
                    './images/1.jpg',
                    './images/2.jpg',
                    './images/3.jpg',
                    './images/4.jpg',
                    './images/5.jpg',
                    './images/6.jpg',
                    './images/7.jpg',
                    './caythong.gif'
                ]
            }
        };

        const STATE = {
            mode: 'TREE', 
            focusTarget: null,
            hand: { detected: false, x: 0, y: 0 },
            rotation: { x: 0, y: 0 },
            isUserRotating: false
        };

        let scene, camera, renderer, composer, mainGroup, clock = new THREE.Clock();
        let particleSystem = [], photoMeshGroup = new THREE.Group();
        let handLandmarker, video, caneTexture; 
        const debugInfo = document.getElementById('debug-info');

        let clickTimer = null;
        let lastPointerDownTime = 0;
        let lastPointerPosition = { x: 0, y: 0 }; 
        let isDragging = false;

        async function init() {
            initThree(); setupEnvironment(); setupLights(); createTextures(); createParticles(); createDust();     
            loadPredefinedImages(); setupPostProcessing(); setupEvents();
            setupTouchInteractions(); 
            await initMediaPipe();    
            
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 800);
            animate();
        }

        function setupTouchInteractions() {
            const canvas = renderer.domElement;

            canvas.addEventListener('pointerdown', (e) => {
                isDragging = false;
                STATE.isUserRotating = true;
                lastPointerDownTime = performance.now();
                lastPointerPosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('pointermove', (e) => {
                if (STATE.isUserRotating && !STATE.hand.detected) {
                    const deltaX = e.clientX - lastPointerPosition.x;
                    const deltaY = e.clientY - lastPointerPosition.y;
                    
                    const sens = isMobile ? 0.008 : 0.004; 
                    STATE.rotation.y += deltaX * sens;
                    STATE.rotation.x += deltaY * sens;

                    lastPointerPosition = { x: e.clientX, y: e.clientY };

                    if (performance.now() - lastPointerDownTime > 150 || Math.abs(deltaX) > 3) {
                        isDragging = true; 
                    }
                }
            });

            const endDrag = () => {
                STATE.isUserRotating = false; 
                if (isDragging) return; 

                const now = performance.now();
                if (now - lastPointerDownTime > 300) return; 

                if (clickTimer === null) {
                    clickTimer = setTimeout(() => { clickTimer = null; handleSingleTap(); }, 250); 
                } else {
                    clearTimeout(clickTimer); clickTimer = null; handleDoubleTap();
                }
            };

            canvas.addEventListener('pointerup', endDrag);
            canvas.addEventListener('pointerleave', endDrag);
        }

        function handleSingleTap() {
            if (STATE.hand.detected || STATE.mode === 'FOCUS') return;
            STATE.mode = (STATE.mode === 'TREE') ? 'SCATTER' : 'TREE';
        }

        function handleDoubleTap() {
             if (STATE.hand.detected) return;
            if (STATE.mode === 'FOCUS') {
                STATE.mode = 'TREE'; STATE.focusTarget = null;
            } else {
                const photos = particleSystem.filter(p => p.type === 'PHOTO');
                if (photos.length > 0) {
                    const randomPhoto = photos[Math.floor(Math.random() * photos.length)];
                    STATE.focusTarget = randomPhoto.mesh;
                    STATE.mode = 'FOCUS';
                }
            }
        }

        async function initMediaPipe() {
            video = document.getElementById('webcam');
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                if (navigator.mediaDevices?.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            facingMode: "user",
                            width: { ideal: 640 }, height: { ideal: 480 } 
                        } 
                    });
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                    debugInfo.innerText = "AI Ready";
                }
            } catch (e) { debugInfo.innerText = "Standard Mode"; }
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    if (result.landmarks && result.landmarks.length > 0) {
                        STATE.hand.detected = true;
                        const lm = result.landmarks[0];
                        STATE.hand.x = (lm[9].x - 0.5) * 2; 
                        STATE.hand.y = (lm[9].y - 0.5) * 2;
                        
                        const wrist=lm[0], middle=lm[9];
                        const size = Math.hypot(middle.x-wrist.x, middle.y-wrist.y);
                        let tips=[lm[8],lm[12],lm[16],lm[20]], avg=0;
                        tips.forEach(t=>avg+=Math.hypot(t.x-wrist.x,t.y-wrist.y));
                        const ext = (avg/4)/size;
                        const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y)/size;

                        if(ext<1.5){ STATE.mode='TREE'; STATE.focusTarget=null; debugInfo.innerText="Hand: Fist"; }
                        else if(pinch<0.35){ 
                            if(STATE.mode!=='FOCUS'){ STATE.mode='FOCUS'; const p=particleSystem.filter(x=>x.type==='PHOTO'); if(p.length) STATE.focusTarget=p[Math.floor(Math.random()*p.length)].mesh; }
                            debugInfo.innerText="Hand: Pinch";
                        } else if(ext>1.7){ STATE.mode='SCATTER'; STATE.focusTarget=null; debugInfo.innerText="Hand: Open"; }
                    } else {
                        STATE.hand.detected = false;
                        debugInfo.innerText = "Touch Mode";
                    }
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.colors.bg); scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01); 
            const fov = isMobile ? 50 : 45;
            camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000); 
            camera.position.set(0, 2, CONFIG.camera.z); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; renderer.toneMappingExposure = 2.0; 
            container.appendChild(renderer.domElement);
            mainGroup = new THREE.Group(); scene.add(mainGroup);
        }
        function setupEnvironment() { const pmremGenerator = new THREE.PMREMGenerator(renderer); scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture; }
        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const inner = new THREE.PointLight(0xffaa00, 2, 20); inner.position.set(0, 5, 0); mainGroup.add(inner);
            const s1 = new THREE.SpotLight(0xffcc66, 1200); s1.position.set(30, 40, 40); scene.add(s1);
            const s2 = new THREE.SpotLight(0x6688ff, 600); s2.position.set(-30, 20, -30); scene.add(s2);
            const fill = new THREE.DirectionalLight(0xffeebb, 0.8); fill.position.set(0, 0, 50); scene.add(fill);
        }
        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.7; bloomPass.strength = 0.45; bloomPass.radius = 0.4;
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);
        }
        function createTextures() {
            const c = document.createElement('canvas'); c.width=128; c.height=128; const ctx=c.getContext('2d');
            ctx.fillStyle='#fff'; ctx.fillRect(0,0,128,128); ctx.fillStyle='#800'; ctx.beginPath();
            for(let i=-128;i<256;i+=32){ctx.moveTo(i,0);ctx.lineTo(i+32,128);ctx.lineTo(i+16,128);ctx.lineTo(i-16,0);} ctx.fill();
            caneTexture = new THREE.CanvasTexture(c); caneTexture.wrapS=caneTexture.wrapT=THREE.RepeatWrapping; caneTexture.repeat.set(3,3);
        }
        class Particle {
            constructor(m, t, d=false) { this.mesh=m; this.type=t; this.isDust=d; this.posTree=new THREE.Vector3(); this.posScatter=new THREE.Vector3(); this.baseScale=m.scale.x; this.spinSpeed=new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).multiplyScalar(t==='PHOTO'?0.3:2.0); this.calculatePositions(); }
            calculatePositions() {
                if(this.type==='PHOTO'){
                    this.posTree.set(0,0,0); const r=8+Math.random()*12, th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
                    this.posScatter.set(r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph)); return;
                }
                const h=CONFIG.particles.treeHeight, t=Math.pow(Math.random(),0.8), y=(t*h)-h/2, rMax=Math.max(0.5, CONFIG.particles.treeRadius*(1.0-t));
                const a=t*50*Math.PI+Math.random()*Math.PI, r=rMax*(0.8+Math.random()*0.4);
                this.posTree.set(Math.cos(a)*r, y, Math.sin(a)*r);
                const rs=this.isDust?(12+Math.random()*20):(8+Math.random()*12), th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
                this.posScatter.set(rs*Math.sin(ph)*Math.cos(th), rs*Math.sin(ph)*Math.sin(th), rs*Math.cos(ph));
            }
            update(dt, mode, focusTargetMesh) {
                let target = this.posTree;
                if (mode === 'SCATTER') target = this.posScatter;
                else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        const desiredWorldPos = new THREE.Vector3(0, 2, 35);
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        target = desiredWorldPos.applyMatrix4(invMatrix);
                    } else target = this.posScatter;
                }
                const speed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 5.0 : 2.0;
                this.mesh.position.lerp(target, speed * dt);

                if(mode==='SCATTER'){ this.mesh.rotation.x+=this.spinSpeed.x*dt; this.mesh.rotation.y+=this.spinSpeed.y*dt; }
                else if(mode==='TREE'){ 
                    if(this.type==='PHOTO'){ this.mesh.lookAt(0,this.mesh.position.y,0); this.mesh.rotateY(Math.PI); }
                    else { this.mesh.rotation.x*=0.9; this.mesh.rotation.z*=0.9; this.mesh.rotation.y+=0.5*dt; }
                }
                if(mode==='FOCUS' && this.mesh===focusTargetMesh) this.mesh.lookAt(camera.position);

                let s = this.baseScale;
                if(this.isDust) { s=this.baseScale*(0.8+0.4*Math.sin(clock.elapsedTime*4+this.mesh.id)); if(mode==='TREE') s=0; }
                else if(mode==='SCATTER' && this.type==='PHOTO') s=this.baseScale*2.5;
                else if(mode==='FOCUS') s=(this.mesh===focusTargetMesh)?4.5:this.baseScale*0.8;
                this.mesh.scale.lerp(new THREE.Vector3(s,s,s), 4*dt);
            }
        }
        function createParticles() {
            const sphere=new THREE.SphereGeometry(0.5,32,32), box=new THREE.BoxGeometry(0.55,0.55,0.55);
            const cane=new THREE.TubeGeometry(new THREE.CatmullRomCurve3([new THREE.Vector3(0,-0.5,0),new THREE.Vector3(0,0.3,0),new THREE.Vector3(0.1,0.5,0),new THREE.Vector3(0.3,0.4,0)]),16,0.08,8,false);
            const mGold=new THREE.MeshStandardMaterial({color:CONFIG.colors.champagneGold, metalness:1, roughness:0.1, envMapIntensity:2}), mGreen=new THREE.MeshStandardMaterial({color:CONFIG.colors.deepGreen, metalness:0.2, roughness:0.8}), mRed=new THREE.MeshPhysicalMaterial({color:CONFIG.colors.accentRed, metalness:0.3, roughness:0.2, clearcoat:1}), mCane=new THREE.MeshStandardMaterial({map:caneTexture, roughness:0.4});
            for(let i=0;i<CONFIG.particles.count;i++){
                let r=Math.random(), m, t;
                if(r<0.4){m=new THREE.Mesh(box,mGreen);t='BOX';} else if(r<0.7){m=new THREE.Mesh(box,mGold);t='GOLD_BOX';} else if(r<0.92){m=new THREE.Mesh(sphere,mGold);t='GOLD_SPHERE';} else if(r<0.97){m=new THREE.Mesh(sphere,mRed);t='RED';} else {m=new THREE.Mesh(cane,mCane);t='CANE';}
                m.scale.setScalar(0.4+Math.random()*0.5); m.rotation.set(Math.random()*6,Math.random()*6,Math.random()*6);
                mainGroup.add(m); particleSystem.push(new Particle(m,t));
            }
            const shape=new THREE.Shape(); for(let i=0;i<10;i++){const a=i*Math.PI/5+Math.PI/2, r=i%2?0.7:1.5; i?shape.lineTo(Math.cos(a)*r,Math.sin(a)*r):shape.moveTo(Math.cos(a)*r,Math.sin(a)*r);}
            const star=new THREE.Mesh(new THREE.ExtrudeGeometry(shape,{depth:0.4,bevelEnabled:true,bevelThickness:0.1,bevelSize:0.1,bevelSegments:2}), new THREE.MeshStandardMaterial({color:0xffdd88,emissive:0xffaa00,metalness:1,roughness:0}));
            star.position.set(0,CONFIG.particles.treeHeight/2+1.2,0); mainGroup.add(star); mainGroup.add(photoMeshGroup);
        }
        function createDust(){
            const m=new THREE.MeshBasicMaterial({color:0xffeebb,transparent:true,opacity:0.8}), g=new THREE.TetrahedronGeometry(0.08);
            for(let i=0;i<CONFIG.particles.dustCount;i++){const me=new THREE.Mesh(g,m); me.scale.setScalar(0.5+Math.random()); mainGroup.add(me); particleSystem.push(new Particle(me,'DUST',true));}
        }
        function addPhotoToScene(t){
            let w=1.2, h=1.2; if(t.image){const a=t.image.width/t.image.height; a>1?h=w/a:w=h*a;}
            const g=new THREE.Group(), f=new THREE.Mesh(new THREE.BoxGeometry(1.4,1.4,0.05), new THREE.MeshStandardMaterial({color:CONFIG.colors.champagneGold,metalness:1,roughness:0.1}));
            const p=new THREE.Mesh(new THREE.PlaneGeometry(w,h), new THREE.MeshBasicMaterial({map:t,side:2}));
            p.position.z=0.04; f.scale.set(w/1.2,h/1.2,1); g.add(f); g.add(p); g.scale.setScalar(0.8);
            photoMeshGroup.add(g); particleSystem.push(new Particle(g,'PHOTO')); updatePhotoLayout();
        }
        function updatePhotoLayout() {
            const p=particleSystem.filter(x=>x.type==='PHOTO'), h=CONFIG.particles.treeHeight*0.9, b=-h/2, s=h/p.length;
            p.forEach((pt,i)=>{
                const y=b+s*i+s/2, nh=(y+CONFIG.particles.treeHeight/2)/CONFIG.particles.treeHeight, r=Math.max(1,CONFIG.particles.treeRadius*(1-nh))+3, a=nh*Math.PI*6+Math.PI/4;
                pt.posTree.set(Math.cos(a)*r, y, Math.sin(a)*r);
            });
        }
        function loadPredefinedImages(){const l=new THREE.TextureLoader(); CONFIG.preload.images.forEach(u=>l.load(u,t=>{t.colorSpace='srgb';addPhotoToScene(t)}))}
        function setupEvents() {
            window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); });
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
                STATE.rotation.y += (STATE.hand.x * Math.PI * 0.9 - STATE.rotation.y) * 3.0 * dt;
                STATE.rotation.x += (STATE.hand.y * Math.PI * 0.25 - STATE.rotation.x) * 3.0 * dt;
            } else {
                if (!STATE.isUserRotating) {
                    if(STATE.mode==='TREE') { STATE.rotation.x*=0.9; STATE.rotation.y+=0.3*dt; }
                    else STATE.rotation.y+=0.1*dt;
                }
            }

            mainGroup.rotation.y = STATE.rotation.y; 
            mainGroup.rotation.x = STATE.rotation.x;
            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
            composer.render();
        }
        init();
    </script>
</body>
</html>
